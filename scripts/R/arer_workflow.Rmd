---
title: "ARER workflow"
author: Michael Cecil
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Cmd+Shift+Enter*. 

```{r}

## need to functionize below, then loop for all years, then calculate CHIRPS indices

library(dplyr)
library(here)
library(sf)
library(raster)
library(conflicted)
library(rlang)
library(scico)
library(ggpubr)
library(assertthat)
library(ggplot2)


conflicted::conflict_prefer("select", "dplyr")
conflicted::conflict_prefer("filter", "dplyr")
options(max.print = 10000)
```


## Load pre-calculated monthly averages for CPC data, filter to TX CPC grids

```{r}

monthly_averages <- read.csv(here("data/outputs/monthly_averages_na_rm.csv"))

## adjust longitude in above to be negative in western hemisphere
monthly_averages$lon <- monthly_averages$lon - 360



## Load CPC grids as spatial object, merge monthly average columns to spatial object
grids <- st_read(here("data/rainfall_index_grids/official_RMA_RI_grid.shp"))
grids$lon <- rowMeans(cbind(grids$X_MIN, grids$X_MAX))
grids$lat <- rowMeans(cbind(grids$Y_MIN, grids$Y_MAX))

monthly_averages_merge <- merge(grids, monthly_averages,
                          by = c("lon", "lat"))



## filter to TX grid cells
year <- 2023
tx_grids <- list.files(here("data/PRF-RI_CHIRPS/"), pattern = paste0("CHIRPS_precip_TX_", year, "_"), full.names = T) %>%
  first() %>% read.csv() %>% pull(GRIDCODE) %>% unique()




```

## merge CPC data with single year of monthly CHIRPS averags (to consolidate data columns)

```{r}

monthly_averages_tx <- monthly_averages_merge %>%
  filter(GRIDCODE %in% tx_grids)
 # select(lon, lat, GRIDCODE, contains("_2021"))


current_year <- 2023

chirps_files <- list.files(here("data/PRF-RI_CHIRPS/"), pattern = paste0("CHIRPS_precip_TX_", current_year, "_"))
if(length(chirps_files) == 11){
  chirps_data <- read.csv(here(paste0("data/PRF-RI_CHIRPS/", chirps_files[grepl("625.csv", chirps_files)])))
  ## rename CHIRPS precip column with interval
  new_name <- paste0("CHIRPS_precip_", current_year, "_625")
  chirps_data[[new_name]] <- chirps_data$CHIRPS_precip
  chirps_data$CHIRPS_precip <- NULL

  ## merge with CPC data, need to have CHIRPS data on left as it has more rows
  chirps_data <- merge(chirps_data,
                       monthly_averages_tx,
                       by = 'GRIDCODE')



  for(interval in 626:635){
    chirps_data_temp <- read.csv(here(paste0("data/PRF-RI_CHIRPS/", chirps_files[grepl(paste0(interval, ".csv"), chirps_files)])))
  ## rename CHIRPS precip column with interval
    new_name <- paste0("CHIRPS_precip_", current_year, "_", interval)
    chirps_data_temp[[new_name]] <- chirps_data_temp$CHIRPS_precip
    chirps_data_temp$CHIRPS_precip <- NULL

  ## merge with CPC data, need to have CHIRPS data on left as it has more rows
    chirps_data <- merge(chirps_data,
                         chirps_data_temp[, c('CHIRPS_LAT', 'CHIRPS_LON', new_name)],
                         by = c('CHIRPS_LAT', 'CHIRPS_LON'))

  }
}
```



## Iterate over other years in CHIRPS data, and join them to "chirps_data"
```{r}

for(year in 1981:2023){
  print(year)
  if(year == current_year){
    next
  }
  chirps_files <- list.files(here("data/PRF-RI_CHIRPS/"), pattern = paste0("CHIRPS_precip_TX_", year, "_"))
 
  if(length(chirps_files) != 11){
    print(paste0('incorrect # of files ', year))
    break
   }
  for(interval in 625:635){
    chirps_data_temp <- read.csv(here(paste0("data/PRF-RI_CHIRPS/", chirps_files[grepl(paste0(interval, ".csv"), chirps_files)])))
  ## rename CHIRPS precip column with interval
    new_name <- paste0("CHIRPS_precip_", year, "_", interval)
    chirps_data_temp[[new_name]] <- chirps_data_temp$CHIRPS_precip
    chirps_data_temp$CHIRPS_precip <- NULL   
  
  ## join data to existing chirps_data df
    chirps_data <- merge(chirps_data,
                         chirps_data_temp[, c('CHIRPS_LAT', 'CHIRPS_LON', new_name)],
                         by = c('CHIRPS_LAT', 'CHIRPS_LON'))
                         
  }
  
}

```


## add columns and calculate CHIRPS monthly index for each interval, starting in year 1981
## We calculate the CHIRPS index starting in 2012, because we need a 30 year baseline (1981-2010) and one year gap (2011)
## Also we need to recalculate CPC index using a 1981 start year.
```{r}

## add CHIRPS index
for(year in 2012:2023){
  print(year)
  for(interval in 625:635){
  #  print(interval)
    current_year_precip <- chirps_data[[paste0("CHIRPS_precip_",
                                                    year,
                                                    "_",
                                                    interval) ]]
    baseline_precip_columns <- paste0("CHIRPS_precip_",
                                      1981:(year - 2),
                                      "_",
                                      interval)
    baseline_avg <- rowMeans(chirps_data[, baseline_precip_columns ])

    chirps_data[[paste0("CHIRPS_index_", year, "_", interval)]] <- round(current_year_precip/baseline_avg,  5)
  }
}

## add CPC index starting in 1981
for(year in 2012:2023){
  print(year)
  for(interval in 625:635){
    current_year_precip <- chirps_data[[paste0("precip_",
                                                    year,
                                                    ".",
                                                    interval) ]]
  #  print(current_year_precip)
    baseline_precip_columns <- paste0("precip_",
                                      1981:(year - 2),
                                      ".",
                                      interval)
  #  print(head(chirps_data[, baseline_precip_columns ]))
    baseline_avg <- rowMeans(chirps_data[, baseline_precip_columns ],
                             na.rm = T)
  #  print(baseline_avg)

    chirps_data[[paste0("cpc_index_1981_base_", year, "_", interval)]] <- round(current_year_precip/baseline_avg,  5)
  }
}


## save chirps_data file which contains all CPC and CHIRPS indices
save(chirps_data, file = paste0(here("data/outputs/"), "chirps_data_TX_ri.rda"))




```



## we also need to calculate a "coarse" version of the CHIRPS index

```{r}

## calculate CHIRPS (coarse) precip and index values 

## coarsen raw precip
chirps_columns <- grep("CHIRPS_precip_", colnames(chirps_data), value = TRUE)

for(name in chirps_columns){
  print(name)
  chirps_data <- chirps_data %>%
    group_by(GRIDCODE) %>%
    mutate(!!paste0(name, "_coarse") := mean(!!sym(name), na.rm = TRUE)) %>%
    ungroup()
}

## update column names so that they end in year and interval
# Rename dataframe columns 
colnames(chirps_data) <- gsub(
  pattern = "^(CHIRPS_precip)_(\\d{4})_(\\d{3})_(coarse)$", 
  replacement = "\\1_\\4_\\2_\\3", 
  x = colnames(chirps_data)
)

## recalculate RI values for CHIRPS-coarse
## add CHIRPS (coarse) index
for(year in 2012:2023){
  print(year)
  for(interval in 625:635){
    current_year_precip <- chirps_data[[paste0("CHIRPS_precip_coarse_",
                                                    year,
                                                    "_",
                                                    interval, "") ]]
    baseline_precip_columns <- paste0("CHIRPS_precip_coarse_",
                                      1981:(year - 2),
                                      "_",
                                      interval, "")
    baseline_avg <- rowMeans(chirps_data[, baseline_precip_columns ])

    chirps_data[[paste0("CHIRPS_index_coarse_", year, "_", interval)]] <- round(current_year_precip/baseline_avg,  5)
  }
}

save(chirps_data, file = paste0(here("data/outputs/"), "chirps_data_TX_ri.rda"))

## view example
View(chirps_data %>% filter(GRIDCODE == 7329) %>% select(CHIRPS_precip_coarse_2017_630, CHIRPS_precip_2017_630, CHIRPS_index_coarse_2017_630, CHIRPS_index_2017_630))

print(chirps_data %>% filter(GRIDCODE == 7329) %>% select(CHIRPS_precip_coarse_2017_630, CHIRPS_precip_2017_630, CHIRPS_index_coarse_2017_630, CHIRPS_index_2017_630) %>% colMeans())
```



## load TX counties
## plot summary stats for Brewster county and all TX counties
## this is to get a birds-eye view of stats
## this chunk isn't doing any new analysis, just plotting
```{r}


tx_counties <- st_read(here("data/Tx_CntyBndry_Jurisdictional_TIGER/Tx_CntyBndry_Jurisdictional_TIGER.shp"))

mask_crop <- function(r, poly){
  r <- mask(crop(r, poly), poly)
}

plot_hist_stats <- function(data, main, min_precip, max_precip){
  hist(data, main = main, xlab = "Values", na.rm = T, xlim = c(min_precip, max_precip))

  # Calculate mean, median, 25th, 75th percentile, and IQR
  mean_value <- mean(data,  na.rm = T)
  median_value <- median(data,  na.rm = T)
  q25 <- quantile(data, 0.25,  na.rm = T)
  q75 <- quantile(data, 0.75,  na.rm = T)
  iqr <- q75 - q25
  
  # Add text above the histogram
  mtext(paste("25th:", round(q25),
              " 50th:", round(median_value),
              " 75th:", round(q75),
              "\n IQR:", round(iqr),
              " Mean:", round(mean_value)),
        side = 3, line = 2)
  
  # Add red dots for 25th, 75th percentiles and median
  points(c(q25, q75, median_value), rep(0, 3), pch = 19, col = "red")
  
  # # Add annotations to the plot
  # text(x = mean_value, y = 0, labels = paste("Mean:", round(mean_value, 2)), pos = 3)
  # text(x = median_value, y = 0, labels = paste("Median:", round(median_value, 2)), pos = 3)
  # text(x = q25, y = 0, labels = paste("25th Percentile:", round(q25, 2)), pos = 3)
  # text(x = q75, y = 0, labels = paste("75th Percentile:", round(q75, 2)), pos = 3)
  # text(x = (q25 + q75) / 2, y = 0, labels = paste("IQR:", round(iqr, 2)), pos = 3)
}

plot_hist_stats_RI <- function(data, main, min_RI, max_RI){
  
  breaks <- seq(0, max_RI + 0.1, by = 0.1)
  colors <- ifelse(breaks < 0.7, "orange", ifelse(breaks >= 0.7 & breaks < 0.9, "yellow", "grey"))

# Plot histogram with specified bin width and colors
  hist(data, 
       breaks = breaks,
       col = colors,
       main = main, 
       xlab = "Values", na.rm = T, 
       xlim = c(0, max_RI + 0.1),
       )

  # Calculate mean, median, 25th, 75th percentile, and IQR
  mean_value <- mean(data,  na.rm = T)
  median_value <- median(data,  na.rm = T)
  q25 <- quantile(data, 0.25,  na.rm = T)
  q75 <- quantile(data, 0.75,  na.rm = T)
  iqr <- q75 - q25
  
  # Add text above the histogram
  mtext(paste("25th:", round(q25, 2),
              " 50th:", round(median_value, 2),
              " 75th:", round(q75, 2),
              "\n IQR:", round(iqr, 2),
              " Mean:", round(mean_value, 2)),
        side = 3, line = 2)
  
  # Add red dots for 25th, 75th percentiles and median
  points(c(q25, q75, median_value), rep(0, 3), pch = 19, col = "red")
  
  # # Add annotations to the plot
  # text(x = mean_value, y = 0, labels = paste("Mean:", round(mean_value, 2)), pos = 3)
  # text(x = median_value, y = 0, labels = paste("Median:", round(median_value, 2)), pos = 3)
  # text(x = q25, y = 0, labels = paste("25th Percentile:", round(q25, 2)), pos = 3)
  # text(x = q75, y = 0, labels = paste("75th Percentile:", round(q75, 2)), pos = 3)
  # text(x = (q25 + q75) / 2, y = 0, labels = paste("IQR:", round(iqr, 2)), pos = 3)
}

## summary stats comparison
plot_cpc_chirps <- function(data, county, year, interval){
  pattern <- paste0(year, ".*", interval, "|", interval, ".*", year)

# Get column names that contain both numbers
  columns <- grep(pattern, colnames(data), value = TRUE)
  print(columns)
  
  data <- data %>% dplyr::select("CHIRPS_LON", "CHIRPS_LAT", all_of(columns))
  print(nrow(data))
  print(names(data))
#  print(str(data))
  #print(data %>% slice(1))

  r <- rasterFromXYZ(data)
  crs(r) <- "+proj=longlat +datum=WGS84 +nodefs"

  print(names(r))
  if(county == "all"){
    data <- data
    county_sf <- st_union(tx_counties)
  } else {
    county_sf <- tx_counties %>% filter(NAME == county) %>% st_transform(., crs(r))
    r <- mask_crop(r, county_sf)
  }
  
  
  ## plots
  # plot 1, precip rasters
  r_precip_cpc <- r[[paste0("precip_", year, ".", interval)]]
  r_precip_chirps <- r[[paste0("CHIRPS_precip_", year, "_", interval)]]
  r_precip_chirps_coarse <- r[[paste0("CHIRPS_precip_coarse_", year, "_", interval)]]
  
  min_precip <- min(cellStats(r_precip_cpc, "min"),
                    cellStats(r_precip_chirps, "min"),
                    cellStats(r_precip_chirps_coarse, "min"))
  
  max_precip <- max(cellStats(r_precip_cpc, "max"),
                    cellStats(r_precip_chirps, "max"),
                    cellStats(r_precip_chirps_coarse, "max"))

  pdf(paste0(county, "_", year, "_", interval, ".pdf"))
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))
 # par(mar = c(3, 3, 2, 1))  # Adjust margins: c(bottom, left, top, right)
  #par(cex = 1.2)
  
  plot(r_precip_cpc, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_precip, max_precip), legend = F, cex.axis = 1.5, cex.main = 2, main = paste0('CPC\n', 'year: ', year, "\ninterval: ", interval))
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot(r_precip_chirps, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_precip, max_precip), legend = F, cex.axis = 1.5, cex.main = 2, main = 'CHIRPS')
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot(r_precip_chirps_coarse, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_precip, max_precip), legend = T, legend.width = 4, legend.args=list(text="mm"), cex.axis = 1.5, cex.main = 2, main = 'CHIRPS coarse')
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot.new()
  # mtext(paste0('Raw precip, year ', year, ' interval ', interval), side = 3, line = 0.5, outer = TRUE, cex = 1.5)

  
  # plot 2, precip scatter
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))
  
  plot(getValues(r_precip_cpc), getValues(r_precip_chirps),
       main = paste0("CPC vs CHIRPS precip \nr = ", 
                     round(cor(getValues(r_precip_cpc), getValues(r_precip_chirps), use="complete.obs"), 2),
                     " p = ", round(cor.test(getValues(r_precip_cpc), getValues(r_precip_chirps))[['p.value']], 3)),
     xlim = c(min_precip, max_precip), ylim = c(min_precip, max_precip),
     xlab = "CPC", ylab = "CHIRPS", pch = 16)
  
  plot(getValues(r_precip_chirps), getValues(r_precip_chirps_coarse),
       main = paste0("CHIRPS vs CHIRPS coarse precip \nr = ", 
                     round(cor(getValues(r_precip_chirps), getValues(r_precip_chirps_coarse), use="complete.obs"), 2),
                     " p = ", round(cor.test(getValues(r_precip_cpc), getValues(r_precip_chirps))[['p.value']], 3)), 
    xlim = c(min_precip, max_precip), ylim = c(min_precip, max_precip),
     xlab = "CHIRPS", ylab = "CHIRPS coarse", pch = 16)
    
  plot(getValues(r_precip_cpc), getValues(r_precip_chirps_coarse), 
       main = paste0("CPC vs CHIRPS coarse precip \nr = ", 
                     round(cor(getValues(r_precip_cpc), getValues(r_precip_chirps_coarse), use="complete.obs"), 2), 
                     " p = ", round(cor.test(getValues(r_precip_cpc), getValues(r_precip_chirps))[['p.value']], 3)), 
    xlim = c(min_precip, max_precip), ylim = c(min_precip, max_precip),
     xlab = "CPC", ylab = "CHIRPS coarse", pch = 16)  
  
  plot.new()
  
  # plot 3, precip distributions
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))


  plot_hist_stats(getValues(r_precip_cpc), main = 'CPC', min_precip, max_precip)
  
  plot_hist_stats(getValues(r_precip_chirps), main = 'CHIRPS', min_precip, max_precip)
  
  plot_hist_stats(getValues(r_precip_chirps_coarse), main = 'CHIRPS coarse', min_precip, max_precip)
  
  plot.new()

  # plot 4, RI rasters
  r_RI_cpc <- r[[paste0("cpc_index_1981_base_", year, "_", interval)]]
  r_RI_chirps <- r[[paste0("CHIRPS_index_", year, "_", interval)]]
  r_RI_chirps_coarse <- r[[paste0("CHIRPS_index_coarse_", year, "_", interval)]]
  
  min_RI <- 0
  
  max_RI <- max(cellStats(r_RI_cpc, "max"),
                    cellStats(r_RI_chirps, "max"),
                    cellStats(r_RI_chirps_coarse, "max"))
  
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))
 # par(mar = c(3, 3, 2, 1))  # Adjust margins: c(bottom, left, top, right)
  #par(cex = 1.2)
  
  plot(r_RI_cpc, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_RI, max_RI), legend = F, cex.axis = 1.5, cex.main = 2, main = paste0('CPC\n', 'year: ', year, "\ninterval: ", interval))
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot(r_RI_chirps, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_RI, max_RI), legend = F, cex.axis = 1.5, cex.main = 2, main = 'CHIRPS')
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot(r_RI_chirps_coarse, col= scico(20, palette = 'vik') %>% rev(), zlim = c(min_RI, max_RI), legend = T, legend.width = 4, legend.args=list(text="RI"), cex.axis = 1.5, cex.main = 2, main = 'CHIRPS coarse')
  plot(st_geometry(county_sf), fill = NA, border = 'red', add = T, lwd = 5)
  
  plot.new()

  # plot 5, RI scatter
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))
  
  plot(getValues(r_RI_cpc), getValues(r_RI_chirps),
       main = paste0("CPC vs CHIRPS RI \nr = ", 
                     round(cor(getValues(r_RI_cpc), getValues(r_RI_chirps), use="complete.obs"), 2),
                     " p = ", round(cor.test(getValues(r_RI_cpc), getValues(r_RI_chirps))[['p.value']], 3)),
     xlim = c(min_RI, max_RI), ylim = c(min_RI, max_RI),
     xlab = "CPC", ylab = "CHIRPS", pch = 16)
  
  plot(getValues(r_RI_chirps), getValues(r_RI_chirps_coarse),
       main = paste0("CHIRPS vs CHIRPS coarse RI \nr = ", 
                     round(cor(getValues(r_RI_chirps), getValues(r_RI_chirps_coarse), use="complete.obs"), 2),
                     " p = ", round(cor.test(getValues(r_RI_cpc), getValues(r_RI_chirps))[['p.value']], 3)), 
    xlim = c(min_RI, max_RI), ylim = c(min_RI, max_RI),
     xlab = "CHIRPS", ylab = "CHIRPS coarse", pch = 16)
    
  plot(getValues(r_RI_cpc), getValues(r_RI_chirps_coarse), 
       main = paste0("CPC vs CHIRPS coarse RI \nr = ", 
                     round(cor(getValues(r_RI_cpc), getValues(r_RI_chirps_coarse), use="complete.obs"), 2), 
                     " p = ", round(cor.test(getValues(r_RI_cpc), getValues(r_RI_chirps))[['p.value']], 3)), 
    xlim = c(min_RI, max_RI), ylim = c(min_RI, max_RI),
     xlab = "CPC", ylab = "CHIRPS coarse", pch = 16)  
  
  plot.new()
  
  # plot 6, RI distributions
  layout(matrix(c(1, 2, 3, 4), nrow = 2, ncol = 2))
  par(mar = c(7, 6, 10, 1))

  plot_hist_stats_RI(getValues(r_RI_cpc), main = 'CPC', min_RI, max_RI)
  
  plot_hist_stats_RI(getValues(r_RI_chirps), main = 'CHIRPS', min_RI, max_RI)
  
  plot_hist_stats_RI(getValues(r_RI_chirps_coarse), main = 'CHIRPS coarse', min_RI, max_RI)
  
  RI_table <- data.frame('RI_below' = seq(0.70, 0.90, 0.05))
  RI_table$CPC_RI <- sapply(RI_table$RI_below, function(x){
    total_pixels <- sum(!is.na(values(r_RI_cpc)))

    # Count the number of pixels below 0.7 (excluding NA values)
    pixels_below_threshold <- sum(values(r_RI_cpc) < x, na.rm = TRUE)
    
    # Calculate the percentage of pixels below the threshold
    percentage_below_threshold <- round((pixels_below_threshold / total_pixels) * 100)
    text <- paste0(percentage_below_threshold, "%")
  })
  RI_table$CPC_CHIRPS <- sapply(RI_table$RI_below, function(x){
    total_pixels <- sum(!is.na(values(r_RI_chirps)))

    # Count the number of pixels below 0.7 (excluding NA values)
    pixels_below_threshold <- sum(values(r_RI_chirps) < x, na.rm = TRUE)
    
    # Calculate the percentage of pixels below the threshold
    percentage_below_threshold <- round((pixels_below_threshold / total_pixels) * 100)
    text <- paste0(percentage_below_threshold, "%")
  })
  RI_table$CPC_CHIRPS_coarse <- sapply(RI_table$RI_below, function(x){
    total_pixels <- sum(!is.na(values(r_RI_chirps_coarse)))

    # Count the number of pixels below 0.7 (excluding NA values)
    pixels_below_threshold <- sum(values(r_RI_chirps_coarse) < x, na.rm = TRUE)
    
    # Calculate the percentage of pixels below the threshold
    percentage_below_threshold <- round((pixels_below_threshold / total_pixels) * 100)
    text <- paste0(percentage_below_threshold, "%")
  })
  
  p4 <- ggtexttable(RI_table)
 # plot.new()
  plot(p4, add = T)
  
  
 # p4 <-  tableGrob(RI_table)
#  grid.draw(table_plot)
 # print(ss)
  
  dev.off()

}
  
plot_cpc_chirps(chirps_data, "Brewster County", "2023", "625")


for(interval in 625:635){
  print(interval)
  plot_cpc_chirps(chirps_data, "Brewster County", "2023", as.character(interval))
}

for(interval in 625:635){
  print(interval)
  plot_cpc_chirps(chirps_data, "all", "2023", as.character(interval))
}

  


```



## CDL proportions

## Calculate county proportions based on CDL data (used in place of county to CPC grid proportions)
## outputs include a cropped and masked CDL raster for TX, 
## and a new file like "cpc_county_areas_cdl_2023.rda" that contains a column for CDL proportions
## this process assumes that the original CPC grid and county intersection list is correct (from "cpc_county_areas.rda")
## THIS TAKES A WHILE


```{r}

calc_cdl_prop <- function(year){
  
  # Load your cdl raster and tx counties
  r <- raster(here(paste0("data/cdl/raw/", year, "_30m_cdls/", year, "_30m_cdls.tif")))
  cdl_names <- read.csv("data/cdl/raw/CDL_codes_names_colors.csv")
  tx_counties <- st_read(here("data/Tx_CntyBndry_Jurisdictional_TIGER/Tx_CntyBndry_Jurisdictional_TIGER.shp"))
  tx_counties$County.Code <- as.numeric(tx_counties$COUNTYID)
  sf_obj <- tx_counties
  
  # Reproject the tx counties to match the raster's CRS
  sf_obj_proj <- st_transform(sf_obj, crs = crs(r))
  
  # Crop and mask the raster to the sf object
  r_masked <- mask(crop(r, sf_obj_proj), sf_obj_proj)
  
  
  ## write cropped and masked cdl raster
  writeRaster(r_masked, file = here(paste0("data/cdl/outputs/cdl_tx_", year, ".tif")))
  
  # Get unique classes and their counts
  class_counts <- freq(r_masked, useNA = "no") %>%
    as.data.frame() %>%
    rename(class = value, count = count)
  
  
  # Calculate pixel area in square meters
  pixel_area <- res(r)[1] * res(r)[2]
  
  # Add area and percentage columns
  total_area <- sum(class_counts$count) * pixel_area
  class_counts <- class_counts %>%
    mutate(area_m2 = count * pixel_area,
           percentage = (area_m2 / total_area) * 100)
  
  # Display the results
  class_counts <- merge(class_counts, cdl_names,
                        by.x = "class",
                        by.y = "Codes")  %>% arrange(-count)
  print(class_counts %>% arrange(-count))
  
  write.csv(class_counts, here(paste0("data/cdl/outputs/class_counts_cdl_", year, ".csv")))
  
  
  
  grids <- st_read(here("data/rainfall_index_grids/official_RMA_RI_grid.shp"))
  grids$lon <- rowMeans(cbind(grids$X_MIN, grids$X_MAX))
  grids$lat <- rowMeans(cbind(grids$Y_MIN, grids$Y_MAX))
  
  grids_rpj <- st_transform(grids, st_crs(tx_counties))
  
  conflicts_prefer(raster::extract)
  
  cpc_county_areas <- read.csv(here("data/tx_county-areas/cpc-county-areas.csv"))
  
  cpc_county_areas$index <- 1:nrow(cpc_county_areas)
  cpc_county_areas$CDL_area2 <- NA
  
  a <- sapply(1:nrow(cpc_county_areas), function(row){
    index <-cpc_county_areas$index[row] 
    print(index)
    cpc_grid <- cpc_county_areas$CPC.Grid.Code[row] 
    county_id <-cpc_county_areas$County.Code[row]  
    intersect_pred <- st_intersects(grids_rpj %>% filter(GRIDCODE == cpc_grid),
                                    tx_counties %>% filter(County.Code == county_id))
    # print(intersect_pred)
    if(length(intersect_pred[[1]]) == 0){
      cpc_county_areas$CDL_area2[index] <- 0
      return(0)
    }
    intersect <- st_intersection(grids_rpj %>% filter(GRIDCODE == cpc_grid),
                                 tx_counties %>% filter(County.Code == county_id))
    intersect_rpj <- st_transform(intersect, crs(r_masked))
    target_classes <- c(176, 37)
    pixel_vals <- extract(r_masked, intersect_rpj)[[1]]
    final_count <- sum(pixel_vals %in% target_classes, na.rm = T)
    # print('next')
    # print('next')
    # print(final_count)
    cpc_county_areas$CDL_area2[index] <- final_count
    return(final_count)
    
  })
  
  cpc_county_areas$cdl_area_2021 <- a
  
  
  cpc_county_areas <- cpc_county_areas %>%
    group_by(County.Code) %>%
    mutate(Proportion_cdl_2021 = cdl_area_2021/ sum(cdl_area_2021))
  
  save(cpc_county_areas, file = here(paste0("data/cdl/outputs/cpc_county_areas_cdl_", year, ".rda")))
  
  print(paste0("cdl proportions for ", year, " completed"))
}

calc_cdl_prop(2023)


```



# Payouts

First determine payouts for given inputs (year, grid, interval, coverage level, productivity factor, grazing/haying, )

Assumptions made:
- constant productivity factor of 1
- rates are constant across years
- rates are consistent despite changing temporal baseline or spatial resolution
- acreage proportionally split among cells in county
- liability, premia, payouts calculated based on acreage for each interval

Equations used:
Dollar Amount of Insurance Per Acre = County-Base Value * Productivity Factor (also = Liability per Acre?)
Liability = Dollar Amount * # Acres
Premium per acre = Liability per acre * rate 
Payment factor = 1 - RI
Indemnity = Liability * payment factor 

Columns to add
CHIRPS data set
- rates, 
- payment factor for each interval x year


## load rates data, join to chirps_data

```{r}

##grazing/haying and county determine prod. factor
##coverage level and county determine rate

## join data from 
### County Base Value
### Rates


load(file = paste0(here("data/outputs/"), "chirps_data_TX_ri.rda"))

rates_files <- list.files(here("data/rates_texas"), full.names = T)

## create single df with all rates information
rates_df <- lapply(rates_files, function(x){
  print(x)
  coverage_level <- strsplit(strsplit(x, "/")[[1]][9], "-")[[1]][4] %>% as.numeric()
  use_level <- strsplit(strsplit(x, "/")[[1]][9], "-")[[1]][3] 
  print(coverage_level)
  print(use_level)
  a <- read.csv(x)
  a$coverage <- coverage_level
  a$use <- use_level
  return(a)
}) %>% do.call('rbind', .)


## add rates for CPC grids and intervals to chirps_data
for (interval in 625:635){
  for(coverage_level in seq(70, 90, 5)){
    print(interval)
    print(coverage_level)
    rates_df_filt <- rates_df %>% filter(Interval.Code == interval) %>% filter(coverage == coverage_level)
    rates_df_filt <- rates_df_filt[!duplicated(rates_df_filt$CPC.Grid.Code), ]

    rate_lookup_table <- setNames( rates_df_filt$Premium.Rate, rates_df_filt$CPC.Grid.Code)
    
    ## add column for rates for specific interval and coverage level to main table
    chirps_data[[paste0("rate_interval_", interval, "_coverage_", coverage_level)]] <- rate_lookup_table[as.character(chirps_data$GRIDCODE)]
  }
}

```

## load CPC and CHIRPS area proportion files

```{r}

county_areas_file_path <- "data/cdl/outputs/cpc_county_areas_cdl_2023.rda"
cpc_proportion_column <- "Proportion_cdl_2023"

load(here(county_areas_file_path))
#cpc_county_areas$Proportion <- cpc_county_areas$Proportion_cdl_2023
cpc_county_areas$Proportion <- cpc_county_areas[[cpc_proportion_column]]

#cpc_county_areas <- read.csv(here("data/tx_county-areas/cpc-county-areas.csv"))
chirps_county_areas <- read.csv(here("data/tx_county-areas/chirps-county-areas.csv"))

```




## add chirps suffixes to "chirps_data"
## so we can merge "chirps_data" with chirps_county_areas file
## RAM PLEASE CHECK THIS

```{r}


## add CHIRPS suffixes
## this adds a column that contains CHIRPS cell IDS like "7032f"...
## that contain a CPC grid ID followed by a letter suffix
## I believe the letter suffixes start in the SE corner, go north for 5 cells total, 
## and then go to the next column west an
## y t o j e
## x s n i d
## w r m h c
## v q l g b
## u p k f a

chirps_data$offset_X_Y <- paste0(chirps_data$CHIRPS_OFFSET_X, "_", chirps_data$CHIRPS_OFFSET_Y)

suffix_dict <- c("0_0" = "u",  "0_1" = "v", "0_2" = "w", "0_3" = "x", "0_4" = "y", "1_0" = "p", "1_1" = "q", "1_2" = "r", "1_3" = "s", "1_4" = "t", "2_0" = "k", "2_1" = "l", "2_2" = "m", "2_3" = "n", "2_4" = "o", "3_0" = "f", "3_1" = "g", "3_2" = "h", "3_3" = "i", "3_4" = "j", "4_0" = "a", "4_1" = "b", "4_2" = "c", "4_3" = "d", "4_4" = "e")

chirps_data$suffix <- suffix_dict[chirps_data$offset_X_Y]

chirps_data$CHIRPS_grid <- paste0(chirps_data$GRIDCODE, chirps_data$suffix)

```




## calculate payouts
## we iterate through TPU file, and calculate payouts for alternative indices
## below chunk contains payout_calc function used to calculate payouts


```{r}

# county_areas_file_path <- "data/cdl/outputs/cpc_county_areas_cdl_2023.rda"
# cpc_proportion_column <- "Proportion_cdl_2023"
# 
# load(here(county_areas_file_path))
# #cpc_county_areas$Proportion <- cpc_county_areas$Proportion_cdl_2023
# cpc_county_areas$Proportion <- cpc_county_areas[[cpc_proportion_column]]
# 
# #cpc_county_areas <- read.csv(here("data/tx_county-areas/cpc-county-areas.csv"))
# chirps_county_areas <- read.csv(here("data/tx_county-areas/chirps-county-areas.csv"))

load_rda_to_variable <- function(file_path, variable_name) {
  # Load the .rda file
  loaded_objects <- load(file_path)
  
  # Assign the loaded object to the specified variable name
  if (length(loaded_objects) != 1) {
    stop("The .rda file must contain exactly one object.")
  }
  
  assign(variable_name, get(loaded_objects), envir = .GlobalEnv)
}


payment_calcs <- function(year, 
                          use_type = "Grazing",
                          index_prefix = "cpc_index_1981_base_", ## index to calculate indemnities for
                          resolution = "CPC",
                          county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
                          proportion_column = "Proportion",  
                          CDL = F){

  year_2 <- substr(year, 3, 4)
  tpu_names <- read.csv(here("data/PRF_tpu/tpu_names.csv"))
  tpu <- read.csv(here(paste0("data/PRF_tpu/SOBSCCTPU", year_2, ".TXT")), sep = "|", header = F)
  names(tpu) <- names(tpu_names)
  
  if(year == 2012){ ## 2012 had different type names
    tpu[tpu$Type.Name == "Grazingland", "Type.Name"] <- "Grazing"
    tpu[tpu$Type.Name == "Hayland", "Type.Name"] <- "Haying"
  }
  
  
  
  tpu <- tpu %>% 
    filter(State.Abbreviation == "TX") %>% 
    filter(Insurance.Plan.Abbreviation == "RI") %>% 
    filter(Liability.Amount > 0) %>% 
    filter(Commodity.Code == 88) %>% ## for PRF
    filter(Type.Name == use_type) %>% 
    filter(Reporting.Level.Type == "Acres") 
  
  
  
  ## filter to only non-organic non-irrigated haying
  if(use_type == "Haying"){
    tpu <- tpu %>% filter(Practice.Code %in% (c(525:535, 625:635))) 
  }
  
  
  cbv_use = c("Grazing" = "grazing", "Haying" = "hayingnonirrigatednonorganic") ## dictionary to use with rates files
  
  tpu$CountyBaseValue <- sapply(tpu$County.Code, function(county_code){
    rates_df_filtered <- rates_df %>%
      filter(County.Code == county_code) %>% 
      filter(use == cbv_use[use_type])
    assert_that(length(unique(rates_df_filtered$County.Base.Value)) == 1)
    return(rates_df_filtered$County.Base.Value[1])
  })
  ri_liability_column <- paste0("Liability_", index_prefix)
  tpu[[ri_liability_column]] <- tpu$CountyBaseValue * tpu$Net.Reporting.Level.Amount
  
  ## iterate through rows of tpu data one at a time, calculating alternate payouts
  ##  for each tpu row, create mini df of overlapping CPC/CHIRPS grid cells with proportions
  for(k in 1:nrow(tpu)){
    current_county_code <- tpu$County.Code[k]
    total_liability <- tpu[[ri_liability_column]][k]
    current_interval <- tpu$Practice.Code[k]
    
    if(use_type == "Haying" && year >=2016){. ## before 2016, the haying intervals are 625:635. Starting 2016 they are 525:535
      current_interval <- current_interval + 100
    }
    
    current_coverage <- (tpu$Coverage.Level.Percent[k]) * 100
    trigger_grid_index <- tpu$Coverage.Level.Percent[k]
    
    ## get RI column
    current_interval_ri_column <- paste0(index_prefix, "_", year, "_", current_interval)
   # print(current_interval_ri_column)
  #  print(names(chirps_data))
    assert_that(current_interval_ri_column %in% names(chirps_data))
    
    ## get rate column
    current_interval_rate_column <- paste0("rate_interval_", current_interval, "_coverage_", current_coverage)
    assert_that(current_interval_rate_column %in% names(chirps_data))

    
    if(resolution == "CHIRPS"){
      chirps_county_areas <- read.csv(here("data/tx_county-areas/chirps-county-areas.csv"))

      mini_df <- chirps_county_areas %>% filter(County.Code == current_county_code)
      mini_df$total_liability <- total_liability
      total_area <- sum(mini_df$Area)
      mini_df$Proportion <- mini_df$Area / total_area
      mini_df$weighted_liability <- mini_df$total_liability * mini_df$Proportion
      
      ## merge w chirps_data, get columns for ri, rating
      mini_df <- merge(mini_df, chirps_data[, c("CHIRPS_grid", 
                                                current_interval_ri_column, 
                                                current_interval_rate_column)],
                       by.x = "CHIRPS.Grid.Code",
                       by.y = "CHIRPS_grid",
                       all.x = T)
      mini_df$premium <- mini_df$weighted_liability * mini_df[[current_interval_rate_column]]
      
      mini_df$payment_factor <- pmax(0, 
                                    (trigger_grid_index - mini_df[[current_interval_ri_column]])/trigger_grid_index)
      mini_df$indemnity <- mini_df$weighted_liability * mini_df$payment_factor
      
    }
    
    if(resolution == "CPC"){
      load_rda_to_variable(here(county_areas_file_path), "cpc_county_areas")
      cpc_county_areas$Proportion <- cpc_county_areas[[proportion_column]]

      mini_df <- cpc_county_areas %>% filter(County.Code == current_county_code)
      mini_df$total_liability <- total_liability
      total_area <- sum(mini_df$Area)
      mini_df$weighted_liability <- mini_df$total_liability * mini_df$Proportion
      
      chirps_data_dedupe <- chirps_data[!duplicated(chirps_data$GRIDCODE), ]
      ## merge w chirps_data, get columns for ri, rating
      mini_df <- merge(mini_df, chirps_data_dedupe[, c("GRIDCODE", 
                                                current_interval_ri_column, 
                                                current_interval_rate_column)],
                       by.x = "CPC.Grid.Code",
                       by.y = "GRIDCODE",
                       all.x = T)
    #  print(mini_df)
      mini_df$premium <- mini_df$weighted_liability * mini_df[[current_interval_rate_column]]
      
      mini_df$payment_factor <- pmax(0, 
                                    (trigger_grid_index - mini_df[[current_interval_ri_column]])/trigger_grid_index)
      mini_df$indemnity <- mini_df$weighted_liability * mini_df$payment_factor
      
    }
    ri_premium_column <- paste0("Premium_", index_prefix)
    tpu[[ri_premium_column]][k] <- sum(mini_df$premium, na.rm = T)

    ri_indemnity_column <- paste0("Indemnity_", index_prefix)
    tpu[[ri_indemnity_column]][k] <- sum(mini_df$indemnity, na.rm = T)
  }
  
  if(CDL == F){
    save(tpu, file = here(paste0("data/payouts/tpu_", use_type, "_", year, "_", index_prefix, ".rda")))
    print(paste0("processing ", year, " ", index_prefix, " completed"))
    return(tpu)
  }
  if(CDL == T){
    save(tpu, file = here(paste0("data/payouts/tpu_", use_type, "_", year, "_", index_prefix, "_cdl.rda")))
    print(paste0("processing ", use_type, " ", year, " ", index_prefix, " completed"))
    return(tpu)
  }
}

#load("/Users/mjcecil/Documents/GitHub/prf-ri/tpu_2023_cpc_index_1981_base.rda")




```


## below chunk loops through each year from 2023 to 2012
## it calculates payouts for the following options
### Grazing - CPC index with 1981 base year
### Grazing - CHIRPS index
### Grazing - CHIRPS index (coarse) averaged to CPC grids
### Grazing - CPC index with 1948 base year
### Same as above for Haying

```{r}
for(year in 2023:2012){
  print(year)
  a1 <- payment_calcs(year,
              use_type = "Grazing",
              index_prefix = "cpc_index_1981_base",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")

  a2 <-  payment_calcs(year,
              use_type = "Grazing",
              index_prefix = "CHIRPS_index",
              resolution = "CHIRPS")

  a3 <- payment_calcs(year,
              use_type = "Grazing",
              index_prefix = "CHIRPS_index_coarse",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")
  
  a4 <- payment_calcs(year,
              use_type = "Grazing",
              index_prefix = "cpc_index",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")

  a5 <- payment_calcs(year,
              use_type = "Haying",
              index_prefix = "cpc_index_1981_base",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")

  a6 <-  payment_calcs(year,
              use_type = "Haying",
              index_prefix = "CHIRPS_index",
              resolution = "CHIRPS")

  a7 <- payment_calcs(year,
              use_type = "Haying",
              index_prefix = "CHIRPS_index_coarse",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")
  
  a8 <- payment_calcs(year,
              use_type = "Haying",
              index_prefix = "cpc_index",
              resolution = "CPC",
              county_areas_file_path = "data/cdl/outputs/cpc_county_areas_cdl_2023.rda",
              proportion_column = "Proportion")
}

```


## consolidate statistics for each year
## create year_df, a data frame listing liabilities/premia/indemnities
## from the statement of business files (raw)
## and comparing them with those from different indices (e.g. "cpc" for cpc with 1981 baseline etc)
```{r}

year_df <- data.frame("year" = 2012:2023)
year_df$grazing_raw_liability <- NA
year_df$grazing_raw_premium <- NA
year_df$grazing_estimated_liability <- NA

year_df$grazing_cpc_premium <- NA
year_df$grazing_cpc_1948_premium <- NA

year_df$grazing_chirps_premium <- NA
year_df$grazing_chirps_coarse_premium <- NA
year_df$grazing_raw_indemnity <- NA
year_df$grazing_cpc_indemnity <- NA
year_df$grazing_cpc_1948_indemnity <- NA

year_df$grazing_chirps_indemnity <- NA
year_df$grazing_chirps_coarse_indemnity <- NA

year_df$haying_raw_liability <- NA
year_df$haying_raw_indemnity <- NA
year_df$haying_estimated_liability <- NA

year_df$haying_cpc_indemnity <- NA
year_df$haying_cpc_1948_indemnity <- NA

year_df$haying_chirps_indemnity <- NA
year_df$haying_chirps_coarse_indemnity <- NA
year_df$haying_raw_premium <- NA
year_df$haying_cpc_premium <- NA
year_df$haying_cpc_1948_premium <- NA

year_df$haying_chirps_premium <- NA
year_df$haying_chirps_coarse_premium <- NA

for(k in 1:nrow(year_df)){
  year <- year_df$year[k]
  
  load_rda_to_variable(here(paste0("data/payouts/tpu_Grazing_", year, "_cpc_index_1981_base.rda")), 
                       "df")
  
  year_df$grazing_raw_liability[k] <- sum(df$Liability.Amount)
  year_df$grazing_raw_premium[k] <- sum(df$Total.Premium.Amount)
  year_df$grazing_raw_indemnity[k] <- sum(df$Indemnity.Amount)
  
  year_df$grazing_estimated_liability[k] <- sum(df$Liability_cpc_index_1981_base)
  
  year_df$grazing_cpc_indemnity[k] <- sum(df$Indemnity_cpc_index_1981_base)
  year_df$grazing_cpc_premium[k] <- sum(df$Premium_cpc_index_1981_base)

  
  
  load_rda_to_variable(here(paste0("data/payouts/tpu_Grazing_", year, "_cpc_index.rda")), 
                       "df")
  

  year_df$grazing_cpc_1948_indemnity[k] <- sum(df$Indemnity_cpc_index)
  year_df$grazing_cpc_1948_premium[k] <- sum(df$Premium_cpc_index)
  
  
  
  
  load_rda_to_variable(here(paste0("data/payouts/tpu_Grazing_", year, "_chirps_index.rda")), 
                       "df")
  year_df$grazing_chirps_indemnity[k] <- sum(df$Indemnity_CHIRPS_index)
  year_df$grazing_chirps_premium[k] <- sum(df$Premium_CHIRPS_index)

  
  load_rda_to_variable(here(paste0("data/payouts/tpu_Grazing_", year, "_chirps_index_coarse.rda")), 
                       "df")
  year_df$grazing_chirps_coarse_indemnity[k] <- sum(df$Indemnity_CHIRPS_index_coarse)
  year_df$grazing_chirps_coarse_premium[k] <- sum(df$Premium_CHIRPS_index_coarse)

  load_rda_to_variable(here(paste0("data/payouts/tpu_Haying_", year, "_cpc_index_1981_base.rda")), 
                       "df")
  
  year_df$haying_raw_liability[k] <- sum(df$Liability.Amount)
  year_df$haying_raw_premium[k] <- sum(df$Total.Premium.Amount)
  year_df$haying_raw_indemnity[k] <- sum(df$Indemnity.Amount)
  year_df$haying_estimated_liability[k] <- sum(df$Liability_cpc_index_1981_base)

  year_df$haying_cpc_indemnity[k] <- sum(df$Indemnity_cpc_index_1981_base)
  year_df$haying_cpc_premium[k] <- sum(df$Premium_cpc_index_1981_base)
  
  load_rda_to_variable(here(paste0("data/payouts/tpu_Haying_", year, "_cpc_index.rda")), 
                       "df")
  

  year_df$haying_cpc_1948_indemnity[k] <- sum(df$Indemnity_cpc_index)
  year_df$haying_cpc_1948_premium[k] <- sum(df$Premium_cpc_index)

  load_rda_to_variable(here(paste0("data/payouts/tpu_Haying_", year, "_chirps_index.rda")), 
                       "df")
  year_df$haying_chirps_indemnity[k] <- sum(df$Indemnity_CHIRPS_index)
  year_df$haying_chirps_premium[k] <- sum(df$Premium_CHIRPS_index)

  load_rda_to_variable(here(paste0("data/payouts/tpu_Haying_", year, "_chirps_index_coarse.rda")), 
                       "df")
  year_df$haying_chirps_coarse_indemnity[k] <- sum(df$Indemnity_CHIRPS_index_coarse)
  year_df$haying_chirps_coarse_premium[k] <- sum(df$Premium_CHIRPS_index_coarse)

  
}

## changes in indemnities, premia
# grazing indemnity
year_df$grazing_ratio_indemnity_grazing_cpc <- round((year_df$grazing_cpc_indemnity)/year_df$grazing_raw_indemnity, 3)
year_df$grazing_ratio_indemnity_grazing_cpc_1948 <- round((year_df$grazing_cpc_1948_indemnity)/year_df$grazing_raw_indemnity, 3)
year_df$grazing_ratio_indemnity_grazing_chirps <- round((year_df$grazing_chirps_indemnity)/year_df$grazing_raw_indemnity, 3)
year_df$grazing_ratio_indemnity_grazing_chirps_coarse <- round((year_df$grazing_chirps_coarse_indemnity)/year_df$grazing_raw_indemnity, 3)

# grazing premia
year_df$grazing_ratio_premium_grazing_cpc <- round((year_df$grazing_cpc_premium)/year_df$grazing_raw_premium, 3)
year_df$grazing_ratio_premium_grazing_cpc_1948 <- round((year_df$grazing_cpc_1948_premium)/year_df$grazing_raw_premium, 3)
year_df$grazing_ratio_premium_grazing_chirps <- round((year_df$grazing_chirps_premium)/year_df$grazing_raw_premium, 3)
year_df$grazing_ratio_premium_grazing_chirps_coarse <- round((year_df$grazing_chirps_coarse_premium)/year_df$grazing_raw_premium, 3)

# haying indemnity
year_df$haying_ratio_indemnity_haying_cpc <- round((year_df$haying_cpc_indemnity)/year_df$haying_raw_indemnity, 3)
year_df$haying_ratio_indemnity_haying_cpc_1948 <- round((year_df$haying_cpc_1948_indemnity)/year_df$haying_raw_indemnity, 3)
year_df$haying_ratio_indemnity_haying_chirps <- round((year_df$haying_chirps_indemnity)/year_df$haying_raw_indemnity, 3)
year_df$haying_ratio_indemnity_haying_chirps_coarse <- round((year_df$haying_chirps_coarse_indemnity)/year_df$haying_raw_indemnity, 3)

# haying premia
year_df$haying_ratio_premium_haying_cpc <- round((year_df$haying_cpc_premium )/year_df$haying_raw_premium, 3)
year_df$haying_ratio_premium_haying_cpc_1948 <- round((year_df$haying_cpc_1948_premium )/year_df$haying_raw_premium, 3)
year_df$haying_ratio_premium_haying_chirps <- round((year_df$haying_chirps_premium)/year_df$haying_raw_premium, 3)
year_df$haying_ratio_premium_haying_chirps_coarse <- round((year_df$haying_chirps_coarse_premium)/year_df$haying_raw_premium, 3)

## cost ratios
year_df$grazing_cr_raw <- round(year_df$grazing_raw_indemnity/ year_df$grazing_raw_premium, 3)
year_df$grazing_cr_cpc <- round(year_df$grazing_cpc_indemnity/ year_df$grazing_cpc_premium, 3)
year_df$grazing_cr_cpc_1948 <- round(year_df$grazing_cpc_1948_indemnity/ year_df$grazing_cpc_premium, 3)
year_df$grazing_cr_chirps <- round(year_df$grazing_chirps_indemnity/ year_df$grazing_chirps_premium, 3)
year_df$grazing_cr_chirps_coarse <- round(year_df$grazing_chirps_coarse_indemnity/ year_df$grazing_chirps_coarse_premium, 3)

year_df$haying_cr_raw <- round(year_df$haying_raw_indemnity/ year_df$haying_raw_premium, 3)
year_df$haying_cr_cpc <- round(year_df$haying_cpc_indemnity/ year_df$haying_cpc_premium, 3)
year_df$haying_cr_cpc_1948 <- round(year_df$haying_cpc_1948_indemnity/ year_df$haying_cpc_1948_premium, 3)
year_df$haying_cr_chirps <- round(year_df$haying_chirps_indemnity/ year_df$haying_chirps_premium, 3)
year_df$haying_cr_chirps_coarse <- round(year_df$haying_chirps_coarse_indemnity/ year_df$haying_chirps_coarse_premium, 3)

## cost ratio comparisons
year_df$grazing_cr_comparison_cpc <- round(year_df$grazing_cr_cpc/ year_df$grazing_cr_raw, 3)
year_df$grazing_cr_comparison_cpc_1948 <- round(year_df$grazing_cr_cpc_1948/ year_df$grazing_cr_raw, 3)
year_df$grazing_cr_comparison_chirps <- round(year_df$grazing_cr_chirps/ year_df$grazing_cr_raw, 3)
year_df$grazing_cr_comparison_chirps_coarse <- round(year_df$grazing_cr_chirps_coarse/ year_df$grazing_cr_raw, 3)

year_df$haying_cr_comparison_cpc <- round(year_df$haying_cr_cpc/ year_df$haying_cr_raw, 3)
year_df$haying_cr_comparison_cpc_1948 <- round(year_df$haying_cr_cpc_1948/ year_df$haying_cr_raw, 3)
year_df$haying_cr_comparison_chirps <- round(year_df$haying_cr_chirps/ year_df$haying_cr_raw, 3)
year_df$haying_cr_comparison_chirps_coarse <- round(year_df$haying_cr_chirps_coarse/ year_df$haying_cr_raw, 3)

year_df$grazing_liability_ratio <- round(year_df$grazing_estimated_liability/year_df$grazing_raw_liability, 3)
year_df$haying_liability_ratio <- round(year_df$haying_estimated_liability/year_df$haying_raw_liability, 3)

write.csv(year_df, file = here("data/payouts/payouts_by_year.csv"))

```

## Calculate within-grid variability (CV) for different variables
## Calculate it for interval precipitation
## Calculate for interval RI (CV and sd)
## payout $ is tricky because the data starts at county level, but we can do it if necessary

```{r}

tx_grid_cells <- unique(chirps_data$GRIDCODE)

## load CPC grids as sf object

grids <- st_read(here("data/rainfall_index_grids/official_RMA_RI_grid.shp")) %>% 
  filter(GRIDCODE %in% tx_grid_cells)
grids$lon <- rowMeans(cbind(grids$X_MIN, grids$X_MAX))
grids$lat <- rowMeans(cbind(grids$Y_MIN, grids$Y_MAX))

grid_variation <- function(grids_df, chirps_df, col_name){
  if(!("count" %in% colnames(grids_df))){
    grids_df$count <- sapply(grids_df$GRIDCODE, function(x){
      chirps_cells <- chirps_df %>% filter(GRIDCODE == x)
      count <- nrow(chirps_cells)
    })
  }
  
  grids_df[[paste0(col_name, "_CV")]] <- sapply(grids_df$GRIDCODE, function(x){
    chirps_cells <- chirps_df %>% filter(GRIDCODE == x)
    cv <- cv(chirps_cells[[col_name]])
  })
  
  grids_df[[paste0(col_name, "_SD")]] <- sapply(grids_df$GRIDCODE, function(x){
    chirps_cells <- chirps_df %>% filter(GRIDCODE == x)
    sd <- sd(chirps_cells[[col_name]])
  })
  return(grids_df)
}

column_to_plot <- "CHIRPS_precip_2016_625"
grids <- grid_variation(grids, chirps_data, column_to_plot)

for(interval in 625:635){
  print(interval)
  column_to_plot <- paste0("CHIRPS_precip_2016_", interval)
  grids <- grid_variation(grids, chirps_data, column_to_plot)
  plot(
    (grids %>% filter(count>= 20)) [paste0(column_to_plot, "_CV")],
    # col = color_palette[as.numeric(class_intervals)],
    # main = paste("Indemnity % Increase in CPC (estimated) vs CPC (2023):", interval),
    # breaks = breaks,
    border = "grey"
  )
}





```







## PLOTS BELOW (in progress)
## chunk below is yearly plots for different stats


```{r}

# Example data
df <- data.frame(
  year = 2012:2023,
  col1 = runif(12, 50, 100),
  col2 = runif(12, 30, 90)
)

df <- year_df 
# Initialize an empty list to store the plots
plots <- list()

pdf("year_df_plots.pdf")

# Loop through each column except 'year'
for (col in names(df)[-1]) {
  # Extract the data for the current column
  current_data <- df[, c("year", col)]
  colnames(current_data) <- c("year", "value")
  
  # Identify points to label (2012, 2023, min, max)
  label_data <- current_data %>%
    filter(
      year %in% c(2012, 2023) |
      value == max(value) |
      value == min(value)
    ) %>%
    distinct()
  
  # Create the plot
  p <- ggplot(current_data, aes(x = year, y = value)) +
    geom_line(color = "steelblue") +
    geom_point(color = "steelblue") +
    geom_text(
      data = label_data,
      aes(label = round(value, 1)),
      nudge_y = 2,
      size = 3
    ) +
    labs(
      title = paste("Plot for", col),
      x = "Year",
      y = "Value"
    ) +
    theme_minimal()
  plot(p)
  # Store the plot in the list
  plots[[col]] <- p
}

dev.off()

# Display all plots
plots

```




## plots and stats
## chunk below is for indemnity channge by county

```{r}

tx_counties <- st_read(here("data/Tx_CntyBndry_Jurisdictional_TIGER/Tx_CntyBndry_Jurisdictional_TIGER.shp"))
tx_counties <- st_set_crs(tx_counties, 4326)  # Example: EPSG 4326 (WGS84)

pdf("tx_counties_RI_comp.pdf")
for(interval in 625:635){
  print(interval)
  tpu_interval_data <- tpu %>% 
    filter(Practice.Code == interval) %>% 
    filter(Coverage.Level.Percent == 0.90)
  tx_counties$County.Code <- as.numeric(tx_counties$COUNTYID)
  tx_counties_temp <- merge(tx_counties[, c("geometry", "County.Code")], tpu_interval_data[, c("County.Code", "Indemnity.Amount",  ri_indemnity_column )],
                       by = "County.Code",
                       all.x = T)
  tx_counties_temp$Indemnity.Amount[is.na(tx_counties_temp$Indemnity.Amount)] <- 0
  tx_counties_temp[[ri_indemnity_column]][is.na(tx_counties_temp[[ri_indemnity_column]])] <- 0
  
  tx_counties_temp[tx_counties_temp$Indemnity.Amount == 0, c("Indemnity.Amount")] <- 0.000001
  tx_counties_temp[tx_counties_temp[[ri_indemnity_column]] == 0, c(ri_indemnity_column)] <- 0.000001


  tx_counties_temp[[paste0("indemnity_pct_increase_", interval)]] <- pmin(2, (tx_counties_temp[[ri_indemnity_column]] - tx_counties_temp$Indemnity.Amount) / tx_counties_temp$Indemnity.Amount)
  
  tx_counties_temp[[paste0("raw_$_increase_", interval)]] <- tx_counties_temp[[ri_indemnity_column]] - tx_counties_temp$Indemnity.Amount


  ## PLOT % increase in indemnity compared to reported indemnity
  column_to_plot <- paste0("indemnity_pct_increase_", interval)

  # Create breaks for the 12 bins between -1 and 2
  breaks <- seq(-1, 2, length.out = 13)
  
  # Assign colors using a color ramp (e.g., "YlOrRd")
  color_palette <- colorRampPalette(brewer.pal(9, "YlOrRd"))(12)
  
  # Classify the data into bins
  class_intervals <- cut(tx_counties_temp[[column_to_plot]], breaks = breaks, include.lowest = TRUE)
  
  # Plot with custom colors
  plot(
    tx_counties_temp[column_to_plot],
    col = color_palette[as.numeric(class_intervals)],
    main = paste("Indemnity % Increase in CPC (estimated) vs CPC (2023):", interval),
    breaks = breaks,
    border = "grey"
  )
  
  # Add a legend
  legend(
    "bottomleft",  # Position of the legend
    legend = levels(class_intervals),  # Labels for bins
    fill = color_palette,  # Colors
    title = "Percent Increase",
    bty = "n"  # Remove box around legend
  )
  
  ## plot raw change in $ indemnity compared to reported indemnity
  column_to_plot <- paste0("raw_$_increase_", interval)
  max_abs_value <- max(abs(tx_counties_temp[[column_to_plot]]))

  # Create breaks for the 12 bins between -1 and 2
  breaks <- pretty(c(-max_abs_value, max_abs_value), n = 13)

 # breaks <- seq(-max_abs_value, max_abs_value, length.out = 13)
  
  # Assign colors using a color ramp (e.g., "YlOrRd")
  color_palette <- colorRampPalette(brewer.pal(9, "YlOrRd"))(length(breaks))
  
  # Classify the data into bins
  class_intervals <- cut(tx_counties_temp[[column_to_plot]], breaks = breaks, include.lowest = TRUE)
  
  # Plot with custom colors
  plot(
    tx_counties_temp[column_to_plot],
    col = color_palette[as.numeric(class_intervals)],
    main = paste("Indemnity $ change (estimated - true):", interval),
    breaks = breaks,
    border = "grey"
  )
  
  # Add a legend
  legend(
    "bottomleft",  # Position of the legend
    legend = levels(class_intervals),  # Labels for bins
    fill = color_palette,  # Colors
    title = "$ Increase",
    bty = "n"  # Remove box around legend
  )
  
  
  plot(tx_counties_temp$Indemnity.Amount, tx_counties_temp[[ri_indemnity_column]])
}

dev.off()



result <- aggregate(Liability.Amount ~ Practice.Name, data = tpu, FUN = sum)

print(result)

a <- read.csv("/Users/mjcecil/Downloads/PRF_data/rates/texas/Texas-2023-haying-non-irrigated-certified-85-rates.csv")

result <- a %>%
 # filter(!is.na(A)) %>%  # Exclude rows where column A is NA
  group_by(County.Name) %>%       # Group by values in column A
  summarise(unique_B_count = n_distinct(CPC.Grid.Code), .groups = "drop")  # Count unique values in B

print(result %>% arrange(unique_B_count))

View(a %>% filter(County.Name == "Rockwall") %>% filter(Interval.Code == 625))

```




```{r}
result <- aggregate(Liability.Amount ~ Practice.Name, data = tpu, FUN = sum)
result$interval <- substr(result$Practice.Name, 1, 9)

result <- result %>%
  group_by(interval) %>%
  mutate(Percentage = (Liability.Amount / sum(Liability.Amount)) * 100)

result
```



